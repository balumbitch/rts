# Практическое задание 2 — Методы программирования в реальном времени для Linux

**Цель:** Изучить и применить на практике ключевые механизмы POSIX и Linux, используемые для разработки систем мягкого и жесткого реального времени.

**Задание 1**: Анализ системных часов (calctime1.c, calctime2.c)

В этом задании предлагается сравнить 2 типа часов в Linux: RT Clock и Monotonic Clock. 

RT Clock отвечает за системное время, т.е то время, которое мы видим в системе. Часы измеряют время с 1 января 1970 года. Их можно изменять вручную, а также они синхронизируется по NTP. Данный вид часов не очень подходит для измерения интервалов времени, особенно очень маленьких, потому что NPT может слегка скорректировать часы в то время, когда происходят измерения, поэтому можно будет наблюдать "скачки" времени или дрейф. 

Monotonic Clock конкретно направлены на измерение интервалов. В отличие от RT Clock эти часы не могут идти в обратную сторону, а могут только увеличиваться, поэтому погрешности становятся меньше и для измерения интервалов стоит использовать именно их.

В файле calctime2.c представлен код, в котором есть цикл, который просыпается каждые 2мс и собирает статистику - реальную разницу во времени. Далее эта статистика используется для расчетов дисперсии, среднего, максимума и минимума. Для сравнения часов предлагается запустить тест с двумя разными видами часов: RT_Clock и Monotonic_Clock.

Результаты для RT_Clock

[![image.png](https://i.postimg.cc/FHNgMHBQ/image.png)](https://postimg.cc/bsVtbpP6)

Результаты для Monotonic_clock

[![image.png](https://i.postimg.cc/gJTZrYss/image.png)](https://postimg.cc/ftYLrQ6S)

Можем видеть, что RT_Clock диспресия больше. Это говорит о малой точности CLOCK_REALTIME часов относительно CLOCK_MONOTONIC

**Задание 2:** Периодический таймер на `timerfd` (`reptimer_timerfd.c`)

**Цель:** Освоить современный Linux API (`timerfd`) для создания периодических событий без использования сигналов.

В этом задании предлагается изучить современный и удобный API для работы с таймерами 'timerfd'. Из названия можем видеть, что данное API реализует таймер с помощью дескрипторов. Работа на основе дескриптора - отличительная черта этого API. Дескриптор делает работу с этим API намного комфортнее, т.к можно использовать базовые системные вызовы. Это делает timerfd универсальным. Также дескрипторы и epoll позволяет организовать асинхронную работу программы в отличие от clock_nanosleep, который просто блокирует работу программы.

Результат работы программы:

[![image.png](https://i.postimg.cc/xdyr08fr/image.png)](https://postimg.cc/t1TvkXnD)

Видим, что кол-во срабатываний всегда равно единице, это значит, что система не сильно нагружена. Если бы система была под нагрузкой, то кол-во срабатываний могло быть больше, т.к планировщик мог вовремя не выделить время для работы программы.

**Задание 3:** Стратегии обработки таймаутов (`timeout_*.c`)

**Цель:** Изучить три разных способа организации ожидания с таймаутом.

В задании предлагается познакомиться с тремя способами организации таймаутов. Программы построены по одному плану, но используются разные API.
 

1. poll() ожидает события на файловых дескрипторах с таймаутом. Его преимуществом является то, что он может наблюдать несколько дескрипторов одновременно. 
 
2. pthread_cond_timedwait() используется для межпоточной синхронизации. Подходит для безопасной работы с потоками. 
 
3. mq_timedreceive() используется для межпроцессной синхронизации через POSIX message queue.
 
4. ppoll() ожидает событие на FD с таймаутом и атомарным разблокированием сигналов. Подходит для безопасной обработки сигналов.

## Контрольные вопросы

1.  **Сравнение `clock_nanosleep` и `nanosleep`**: Почему для периодических задач в СРВ `clock_nanosleep` с абсолютным временем всегда предпочтительнее, чем относительный `nanosleep`? Проиллюстрируйте проблему накопления ошибки на гипотетическом примере.

clock_nanosleep с абсолютным временем (TIMER_ABSTIME) предотвращает накопление ошибки. Пример: задача с периодом 10 мс. При nanosleep(10ms) после 1000 циклов набегает ошибка ~1-10 мс из-за времени обработки. При clock_nanosleep(TIMER_ABSTIME, next_deadline) каждый цикл стартует точно в расчетное время.

2.  **`timerfd` vs Сигналы**: POSIX-таймеры (`timer_create`) могут доставлять события через сигналы. Почему `timerfd` считается более надежным и предсказуемым механизмом для построения циклов обработки событий (event loops)?

timerfd интегрируется с epoll/select, позволяя единообразно обрабатывать таймеры с другими событиями ввода-вывода. Сигналы асинхронны, требуют обработчиков, могут теряться при реентерабельности, сложны в отладке.

3.  **Инверсия приоритетов**: Хотя мы не реализовывали это напрямую, опишите сценарий, в котором использование `pthread_mutex` может привести к инверсии приоритетов. Какие атрибуты мьютекса (см. `pthread_mutexattr_setprotocol`) помогают решить эту проблему?

Сценарий: низкоприоритетная задача A блокирует мьютекс, высокоприоритетная задача B ожидает его, средняя задача C вытесняет pthread_mutexattr_setprotocol() с PTHREAD_PRIO_INHERIT (A временно получает приоритет B) или PTHREAD_PRIO_PROTECT (использование приоритета потолка).

4.  **Предсказуемость vs Производительность**: Объясните, почему техники, использованные в задании 4 (`SCHED_FIFO`, привязка к ядру), могут *уменьшить* общую производительность системы, но при этом *повысить* ее предсказуемость.

SCHED_FIFO и привязка к ядру уменьшают переключения контекста и миграцию между ядрами, повышая предсказуемость для конкретной задачи, но снижают общую пропускную способность системы из-за недоиспользования ресурсов и возможного голодания других задач.

5.  **Жесткое реальное время**: Достаточно ли рассмотренных техник для построения системы жесткого реального времени на стандартном ядре Linux? Что такое `PREEMPT_RT` и какие фундаментальные изменения в ядре он вносит для обеспечения детерминизма?

Рассмотренных техник недостаточно. PREEMPT_RT — патч ядра Linux, который:

- Делает большинство секций ядра преemptible (вытесняемыми)

- Заменяет spinlocks на mutexes с приоритетным наследованием

- Реализует приоритетную инверсию для IRQ-обработчиков

- Обеспечивает детерминированную задержку вытеснения (микросекунды вместо миллисекунд).