# Практическое задание 5 — Управление памятью в системах реального времени

В механизме вирутальной памяти может возникать ошибка отказа страницы, она возникает, когда процесс обращается к участку памяти, который еще не загружен в RAM (или был выгружен на диск в swap-раздел). Обработка этого события ядром ОС приостанавливает процесс и вызывает значительную, а главное — **непредсказуемую задержку**.

Для решения этой проблемы можно использовать блокировку памяти (`mlock`/`mlockall`). Сравним работу двух программ с применением блокировки и без ее применения.

Без применения:

[![image.png](https://i.postimg.cc/MKkqs5xv/image.png)](https://postimg.cc/3WZsNgkT)4

С применением:

[![image.png](https://i.postimg.cc/ydS2cqDb/image.png)](https://postimg.cc/S2kZbv76)

Вывод: механиз блокировки памяти значительно снижает задержки в работе программы.

### Контрольные вопросы

1.  Почему для `mlockall` могут требоваться права суперпользователя? Какой есть способ дать процессу эти права без запуска через `sudo`?

Mlockall может закрыть много страниц в RAM и тем самым лишить систему памяти. Ядро ограничивает это через RLIMIT_MEMLOCK, а повышенный лимит требует права суперпользователя.

2.  Объясните разницу между `MCL_CURRENT` и `MCL_FUTURE`. Почему важно использовать оба флага?

MCL_CURRENT — залочить уже отображённые в адресное пространство страницы.
MCL_FUTURE — автоматически залочить все будущие отображения.

Важно использовать оба, иначе часть памяти останется незалоченной и могут возникать page fault.

3.  В чем главный недостаток реализованного вами пула памяти? (Подсказка: что если вам понадобятся блоки другого размера?)

Жёсткая привязка к одному размеру блоков.

4.  Может ли `mlockall` защитить от всех источников задержек, связанных с памятью? (Подсказка: подумайте о кэше CPU и TLB).

Mlockall защищает только от задержек из-за подкачки/выгрузки страниц (swap, major page fault).
Он не избавляет, например, от промахов кэша CPU (L1/L2/L3)
